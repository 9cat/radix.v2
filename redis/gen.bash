#!/bin/bash
# used to regenerate command.go
set -e

command="command.go"

if [ $# == 1 ]; then
    redis_h=$1
else
    redis_h=`locate redis.h | grep '/redis\.h$' | head -n 1`
fi

if [ ! -e "$redis_h" ]; then
    echo "usage: $0 path/to/redis.h"
    echo "(or make sure you have mlocate and redis-devel installed)"
    exit 1
fi

cmds=`cat $redis_h | egrep '^void ([a-z])*Command\(' | sed 's/void \([a-z]*\)Command.*/\1/'`
# for some reason, some commands arent in redis.h
cmds=("${cmds[@]}" "smembers")
# sort
cmds=($(printf "%s\n" "${cmds[@]}"|sort))
cat >$command <<EOF
// Generated by gen.bash.
// DO NOT EDIT THIS FILE DIRECTLY!

package redis

type cmdName string

const (
EOF

# command names
for cmd in ${cmds[@]}; do
	echo "	${cmd}_ cmdName = \"${cmd^^}\"" >>$command
done
echo -e ")
" >>$command

# commands
for cmd in ${cmds[@]}; do
	keyword="${cmd~}"
    echo "
// $keyword calls Redis ${cmd^^} command. 
func (c *Client) $keyword(args ...interface{}) *Reply {
	return c.command(${cmd}_, args...)
}" >>$command
done

# Async commands
for cmd in ${cmds[@]}; do
	keyword="${cmd~}"
    echo "
// Async$keyword calls Redis ${cmd^^} asynchronously. 
func (c *Client) Async$keyword(args ...interface{}) Future {
	return c.asyncCommand(${cmd}_, args...)
}" >>$command
done

# MultiCommand
for cmd in ${cmds[@]}; do
	keyword="${cmd~}"
    echo "
// $keyword queues a Redis ${cmd^^} command for later execution. 
func (mc *MultiCommand) $keyword(args ...interface{}) {
	mc.command(cmdName(${cmd}_), args...)
}" >>$command
done

gofmt -tabs=true -tabwidth=4 -w $command
